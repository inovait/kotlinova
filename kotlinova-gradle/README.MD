# Gradle Utilities

Direct gradle usage:

```kotlin
classpath("si.inova.kotlinova:gradle:X.Y.Z")
```

Version catalogs usage:

```toml
[versions]
kotlinova = "X.Y.Z"
```

```toml
[libraries]
kotlinova-gradle = { module = "si.inova.kotlinova:gradle", version.ref = "kotlinova" }
```

```kotlin
classpath(libs.kotlinova.gradle)
```

Replace `X.Y.Z` with latest version. Check out [changelog](../CHANGELOG.MD) to see what is the latest version.

# Features

## Adding kotlinova plugin

All features above require "kotlinova" plugin to be added to the project. Then you can use `kotlinova` extension:

```kotlin
plugins {
   id("kotlinova")
}

kotlinova {
   ...
}
```

## Automatic versions catalog version bump

If your project is
using [Gradle's version catalogs in toml file](https://docs.gradle.org/current/userguide/platforms.html#sub:conventional-dependencies-toml)
,
this plugin can automatically update version of all used libraries to latest version.

First, you need to setup [Gradle Versions Plugin](https://github.com/ben-manes/gradle-versions-plugin). This plugin will
determine latest version for all dependencies in your project:

```kotlin
import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask

plugins {
   id("com.github.ben-manes.versions")
}

tasks.withType<DependencyUpdatesTask> {
   // Output library version report into json that toml-version-bump will read
   reportfileName = "versions"
   outputFormatter = "json"

   // Recommended: also set rejectVersionIf here. See documentation of the Versions plugin.
}
```

Then you can setup automatic version bumping on your top module (for example `app` module):

```kotlin
kotlinova {
   tomlVersionBump {
      // Search for all instances of versions.json, generated by the gradle versions plugin.
      versionReportFiles = fileTree(rootDir).apply {
         include("**/build/dependencyUpdates/versions.json")
      }

      // Location of the toml file that we should bump versions for
      tomlFile = File(rootDir, "gradle/libs.versions.toml")
   }
}
```

After all of that, you can update all of your libraries with a single command:

`./gradlew dependencyUpdates -q && ./gradlew app:updateLibsToml -q`

# Detekt sarif report merging

This allows one-line enabling of the
[Detekt's report merging mechanism](https://detekt.dev/docs/introduction/reporting/#merging-reports) that will setup detekt tasks
in this project with .sarif output and then merge output of all detekt tasks to `merge.sarif` file in top level project's root.

```kotlin
kotlinova {
   mergeDetektSarif = true
}
```

# Android Lint sarif report merging

This allows one-line enabling of the
[Detekt's report merging mechanism](https://detekt.dev/docs/introduction/reporting/#merging-reports) that will setup
merge sarif output of all Android Lint tasks to `merge.sarif` file in top level project's root.

```kotlin
kotlinova {
   mergeAndroidLintSarif = true
}
```

Note, that you still need to enable sarif manually in lint configuration:

```kotlin
android {
   sarifReport = true
}
}
```

Even if you don't use Detekt, you still need it on the classpath for this to work,
since it is using merging mechanism from Detekt plugin

# Detekt's pre-commit hook

This allows one-line enabling of the
[Detekt's pre-commit hook](https://detekt.dev/docs/gettingstarted/git-pre-commit-hook/) that will setup
detekt to only scan for staged git files whenever `-precommit` flag is added to the gradle's command line.

```kotlin
kotlinova {
   enableDetektPreCommitHook = true
}
```

To use, add `-Pprecommit=true` flag to your pre-commit hook. For example:

```kotlin
./gradlew - Pprecommit = true detekt
```

# Android benchmark result upload to Google Cloud metrics

Plugin also contains a task that will upload results
from [Macrobenchmark](https://developer.android.com/topic/performance/benchmarking/macrobenchmark-overview)
to [Google Cloud Monitoring](https://cloud.google.com/monitoring) where you can put results into charts and/or set up
alerts when results change.

This is similar
to [Google's Macrobenchmarking sample](https://github.com/android/performance-samples/tree/main/MacrobenchmarkSample/ftl),
except that no Firebase functions are required (everything happens locally in Gradle).

Benchmark results are uploaded as custom metrics under, `custom.googleapis.com/android/{TEST_NAME}/{METRIC_NAME}/{PART}`,
where `TEST_NAME` is the name of the test function that generated the result, converted to camel_case, `METRIC_NAME` is the
remapped
name of the defined metric (see below for mapping info) and `PART` is the name of the result part, such as `median` or `P99`.

To authenticate with Google Cloud, you need to set `GOOGLE_APPLICATION_CREDENTIALS` environment variable.
See [their documentation](https://cloud.google.com/docs/authentication/application-default-credentials#GAC) for more info.

You enable the upload by registering a new monitoring export task:

```kotlin
val benchmarkResultsUpload by tasks.registering(GoogleCloudBenchmarkUpload::class) {
   // Project ID of the target google cloud project
   googleCloudProjectId = "id-of-the-target-google-cloud-project"

   // Set of JSON benchmark result JSON files
   benchmarkResultFiles.from(
      fileTree("/path/to/benchmark/json/results/") {
         include("*-portrait/artifacts/sdcard/Download/*-benchmarkData.json")
      }
   )

   // Map that converts metric name (which can contain invalid characters like spaces) into
   // simple camel_case name that can be used in Google Cloud's custom metric path
   metricMap.putAll(
      mapOf(
         "JIT compiling %Count" to "jit_count",
         "timeToInitialDisplayMs" to "time_to_initial_display",
      )
   )
}
```

then you call the task (`./gradlew benchmarkResultsUpload`) to initiate the upload.
